<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pong with AI</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
        #score { position: absolute; top: 10px; left: 10px; color: white; font: 24px Arial; }
    </style>
</head>
<body>
    <div id="score">Score: 0 - 0</div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        // Constants
        const PADDLE_WIDTH = 20;
        const PADDLE_HEIGHT = 100;
        const PADDLE_SPEED = 300;
        const BALL_RADIUS = 10;
        const BALL_SPEED = 300;

        // Game state
        let playerScore = 0, aiScore = 0;

        // Objects
        const paddleLeft = { x: 50, y: 250, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, velocityY: 0 };
        const paddleRight = { x: 730, y: 250, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, velocityY: 0 };
        const ball = { x: 400, y: 300, radius: BALL_RADIUS, velocityX: -BALL_SPEED, velocityY: 0 };

        // Input
        const keys = { w: false, s: false };
        window.addEventListener('keydown', e => { if (e.key in keys) keys[e.key] = true; });
        window.addEventListener('keyup', e => { if (e.key in keys) keys[e.key] = false; });

        // AI prediction
        function predictBallY() {
            const H = canvas.height;
            if (ball.velocityX > 0) {
                const t = (paddleRight.x - ball.x) / ball.velocityX;
                const y_unfolded = ball.y + ball.velocityY * t;
                const temp = (y_unfolded % (2 * H) + 2 * H) % (2 * H);
                return temp <= H ? temp : 2 * H - temp;
            }
            return H / 2;
        }

        // Update
        function update(delta) {
            // Player paddle
            if (keys.w) paddleLeft.velocityY = -PADDLE_SPEED;
            else if (keys.s) paddleLeft.velocityY = PADDLE_SPEED;
            else paddleLeft.velocityY = 0;

            // AI paddle
            const targetY = predictBallY();
            const paddleCenter = paddleRight.y + paddleRight.height / 2;
            if (targetY > paddleCenter + 10) paddleRight.velocityY = PADDLE_SPEED;
            else if (targetY < paddleCenter - 10) paddleRight.velocityY = -PADDLE_SPEED;
            else paddleRight.velocityY = 0;

            // Move paddles
            paddleLeft.y += paddleLeft.velocityY * delta;
            paddleRight.y += paddleRight.velocityY * delta;
            paddleLeft.y = Math.max(0, Math.min(canvas.height - paddleLeft.height, paddleLeft.y));
            paddleRight.y = Math.max(0, Math.min(canvas.height - paddleRight.height, paddleRight.y));

            // Ball movement
            ball.x += ball.velocityX * delta;
            ball.y += ball.velocityY * delta;

            // Wall collision
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
                ball.velocityY = -ball.velocityY;
            }

            // Paddle collision
            if (ball.x - ball.radius < paddleLeft.x + paddleLeft.width &&
                ball.y > paddleLeft.y && ball.y < paddleLeft.y + paddleLeft.height) {
                ball.velocityX = BALL_SPEED;
                ball.velocityY = ((ball.y - paddleLeft.y) / paddleLeft.height - 0.5) * 600;
            }
            if (ball.x + ball.radius > paddleRight.x &&
                ball.y > paddleRight.y && ball.y < paddleRight.y + paddleRight.height) {
                ball.velocityX = -BALL_SPEED;
                ball.velocityY = ((ball.y - paddleRight.y) / paddleRight.height - 0.5) * 600;
            }

            // Scoring
            if (ball.x < 0) {
                aiScore++;
                ball.x = 400; ball.y = 300; ball.velocityX = BALL_SPEED; ball.velocityY = 0;
            } else if (ball.x > canvas.width) {
                playerScore++;
                ball.x = 400; ball.y = 300; ball.velocityX = -BALL_SPEED; ball.velocityY = 0;
            }
            scoreDisplay.textContent = `Score: ${playerScore} - ${aiScore}`;
        }

        // Render
        function render() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(paddleLeft.x, paddleLeft.y, paddleLeft.width, paddleLeft.height);
            ctx.fillRect(paddleRight.x, paddleRight.y, paddleRight.width, paddleRight.height);
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            const delta = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            update(delta);
            render();
            requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
